{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _constants = require(\"./constants\");\nvar _errorSerialization = require(\"./errorSerialization\");\n\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n * @param {Object} info Information about the local and remote windows.\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\n * while the values are the method functions.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Function} A function that may be called to disconnect the receiver.\n */\nvar _default = (info, methods, log) => {\n  const localName = info.localName,\n    local = info.local,\n    remote = info.remote,\n    originForSending = info.originForSending,\n    originForReceiving = info.originForReceiving;\n  let destroyed = false;\n  log(\"\".concat(localName, \": Connecting call receiver\"));\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\n      return;\n    }\n    if (event.origin !== originForReceiving) {\n      log(\"\".concat(localName, \" received message from origin \").concat(event.origin, \" which did not match expected origin \").concat(originForReceiving));\n      return;\n    }\n    const _event$data = event.data,\n      methodName = _event$data.methodName,\n      args = _event$data.args,\n      id = _event$data.id;\n    log(\"\".concat(localName, \": Received \").concat(methodName, \"() call\"));\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(\"\".concat(localName, \": Sending \").concat(methodName, \"() reply\"));\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(\"\".concat(localName, \": Unable to send \").concat(methodName, \"() reply due to destroyed connection\"));\n          return;\n        }\n        const message = {\n          penpal: _constants.REPLY,\n          id,\n          resolution,\n          returnValue\n        };\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\n          message.returnValueIsError = true;\n        }\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === _constants.DATA_CLONE_ERROR) {\n            remote.postMessage({\n              penpal: _constants.REPLY,\n              id,\n              resolution: _constants.REJECTED,\n              returnValue: (0, _errorSerialization.serializeError)(err),\n              returnValueIsError: true\n            }, originForSending);\n          }\n          throw err;\n        }\n      };\n    };\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\n  };\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\n  };\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_constants","require","_errorSerialization","_default","info","methods","log","localName","local","remote","originForSending","originForReceiving","destroyed","concat","handleMessageEvent","event","source","data","penpal","CALL","origin","_event$data","methodName","args","id","createPromiseHandler","resolution","returnValue","message","REPLY","REJECTED","Error","serializeError","returnValueIsError","postMessage","err","name","DATA_CLONE_ERROR","Promise","resolve","apply","then","FULFILLED","addEventListener","MESSAGE","removeEventListener","module"],"sources":["/Users/fabienpicard/Projects/astro-website/node_modules/penpal/lib/connectCallReceiver.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorSerialization = require(\"./errorSerialization\");\n\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n * @param {Object} info Information about the local and remote windows.\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\n * while the values are the method functions.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Function} A function that may be called to disconnect the receiver.\n */\nvar _default = (info, methods, log) => {\n  const localName = info.localName,\n        local = info.local,\n        remote = info.remote,\n        originForSending = info.originForSending,\n        originForReceiving = info.originForReceiving;\n  let destroyed = false;\n  log(`${localName}: Connecting call receiver`);\n\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\n      return;\n    }\n\n    if (event.origin !== originForReceiving) {\n      log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n      return;\n    }\n\n    const _event$data = event.data,\n          methodName = _event$data.methodName,\n          args = _event$data.args,\n          id = _event$data.id;\n    log(`${localName}: Received ${methodName}() call`);\n\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(`${localName}: Sending ${methodName}() reply`);\n\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n          return;\n        }\n\n        const message = {\n          penpal: _constants.REPLY,\n          id,\n          resolution,\n          returnValue\n        };\n\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\n          message.returnValueIsError = true;\n        }\n\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === _constants.DATA_CLONE_ERROR) {\n            remote.postMessage({\n              penpal: _constants.REPLY,\n              id,\n              resolution: _constants.REJECTED,\n              returnValue: (0, _errorSerialization.serializeError)(err),\n              returnValueIsError: true\n            }, originForSending);\n          }\n\n          throw err;\n        }\n      };\n    };\n\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\n  };\n\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}