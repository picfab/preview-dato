{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _constants = require(\"./constants\");\nvar _errorSerialization = require(\"./errorSerialization\");\n\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n * @param {Object} info Information about the local and remote windows.\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\n * while the values are the method functions.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Function} A function that may be called to disconnect the receiver.\n */\nvar _default = (info, methods, log) => {\n  const localName = info.localName,\n    local = info.local,\n    remote = info.remote,\n    originForSending = info.originForSending,\n    originForReceiving = info.originForReceiving;\n  let destroyed = false;\n  log(`${localName}: Connecting call receiver`);\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\n      return;\n    }\n    if (event.origin !== originForReceiving) {\n      log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n      return;\n    }\n    const _event$data = event.data,\n      methodName = _event$data.methodName,\n      args = _event$data.args,\n      id = _event$data.id;\n    log(`${localName}: Received ${methodName}() call`);\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(`${localName}: Sending ${methodName}() reply`);\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n          return;\n        }\n        const message = {\n          penpal: _constants.REPLY,\n          id,\n          resolution,\n          returnValue\n        };\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\n          message.returnValueIsError = true;\n        }\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === _constants.DATA_CLONE_ERROR) {\n            remote.postMessage({\n              penpal: _constants.REPLY,\n              id,\n              resolution: _constants.REJECTED,\n              returnValue: (0, _errorSerialization.serializeError)(err),\n              returnValueIsError: true\n            }, originForSending);\n          }\n          throw err;\n        }\n      };\n    };\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\n  };\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\n  };\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_constants","require","_errorSerialization","_default","info","methods","log","localName","local","remote","originForSending","originForReceiving","destroyed","handleMessageEvent","event","source","data","penpal","CALL","origin","_event$data","methodName","args","id","createPromiseHandler","resolution","returnValue","message","REPLY","REJECTED","Error","serializeError","returnValueIsError","postMessage","err","name","DATA_CLONE_ERROR","Promise","resolve","apply","then","FULFILLED","addEventListener","MESSAGE","removeEventListener","module"],"sources":["/Users/fabienpicard/Projects/astro-website/node_modules/penpal/lib/connectCallReceiver.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorSerialization = require(\"./errorSerialization\");\n\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n * @param {Object} info Information about the local and remote windows.\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\n * while the values are the method functions.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Function} A function that may be called to disconnect the receiver.\n */\nvar _default = (info, methods, log) => {\n  const localName = info.localName,\n        local = info.local,\n        remote = info.remote,\n        originForSending = info.originForSending,\n        originForReceiving = info.originForReceiving;\n  let destroyed = false;\n  log(`${localName}: Connecting call receiver`);\n\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\n      return;\n    }\n\n    if (event.origin !== originForReceiving) {\n      log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n      return;\n    }\n\n    const _event$data = event.data,\n          methodName = _event$data.methodName,\n          args = _event$data.args,\n          id = _event$data.id;\n    log(`${localName}: Received ${methodName}() call`);\n\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(`${localName}: Sending ${methodName}() reply`);\n\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n          return;\n        }\n\n        const message = {\n          penpal: _constants.REPLY,\n          id,\n          resolution,\n          returnValue\n        };\n\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\n          message.returnValueIsError = true;\n        }\n\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === _constants.DATA_CLONE_ERROR) {\n            remote.postMessage({\n              penpal: _constants.REPLY,\n              id,\n              resolution: _constants.REJECTED,\n              returnValue: (0, _errorSerialization.serializeError)(err),\n              returnValueIsError: true\n            }, originForSending);\n          }\n\n          throw err;\n        }\n      };\n    };\n\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\n  };\n\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}